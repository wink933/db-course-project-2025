# 06_代码结构与实现原理：个人媒体资产管理系统

本文档面向“第一次接触此仓库的读者”，目标是：
- 让你能快速理解整个系统如何工作（模块怎么分、数据怎么流、接口怎么调用）；
- 让你能对照代码定位功能实现的位置；
- 让你能解释清楚：技术栈选择原因、同步协议设计、局域网传输原理。

> 范围：以当前仓库可运行代码为准（桌面端 Node/Express/SQLite/Web UI/Electron + Android 原生 App）。

---

## 1. 总体架构（两端一库 + 多端索引）

系统由三部分组成：

1) **桌面端服务（server.js）**
- Express 提供 HTTP API：媒体/文件夹/标签/设备/同步/传输
- SQLite（better-sqlite3）存储所有“元数据”（media_items、folders、tags、devices、storage_locations…）
- 同时提供静态 Web UI（public/），浏览器用 fetch 调用 API

2) **桌面端壳（electron/main.js）**
- 可选：把桌面端服务“装进”Electron
- 负责：启动 server、端口占用兜底、设置数据目录（DB+uploads）、弹窗展示 LAN 访问地址

3) **移动端 App（mobile-android/）**
- 本地索引库：Room(SQLite) 保存“我在手机上选过哪些文件（content://）”
- 同步：对桌面端 push/pull/bootstrap 拉取元数据
- 局域网文件服务：手机端内置轻量 HTTP server（支持 Range），让桌面端“按需下载/流式读取”手机里的文件

关键设计点：
- **系统管理的是“资产索引/元数据”**，不是网盘：默认不同步文件本体。
- 每个资源（media_items）可以有多个位置副本（storage_locations），每个位置关联一个设备（devices）。

---

## 2. 目录结构与职责

- server.js
  - 桌面端 HTTP API + SQLite 读写 + 运行时迁移（增加列/索引）
  - 同步协议、局域网传输的核心逻辑

- db/schema.sql
  - 建表 SQL：users/devices/folders/tags/media_items/storage_locations/media_tags
  - 外键约束和索引

- public/
  - index.html：页面结构
  - app.js：前端状态管理 + fetch API + 渲染 + 交互（拖拽、批量操作、同步、传输弹窗等）
  - styles.css：样式

- electron/main.js
  - Electron 主进程：启动 server（端口占用自动换端口），并打开 BrowserWindow
  - 统一 userData 目录：确保开发模式与打包模式读写同一份 DB/Uploads

- scripts/
  - init-db.js：初始化 DB（首次创建 owner / 默认设备 / 默认文件夹）
  - smoke-check.js：启动临时 server 并调用关键 API，验证最小闭环

- mobile-android/
  - AppDatabase / Dao / Repository：Room 本地索引库
  - MainViewModel：同步流程（push→pull→bootstrap）与 UI 状态
  - SyncClient：HTTP 客户端 + JSON 解析
  - LanFileServer：手机端 HTTP server（对桌面端提供文件读取能力）

---

## 3. 数据库逻辑结构（核心表 + 关键关系）

以 db/schema.sql 为准：

### 3.1 users（单用户 MVP）
- 当前实现为“单用户 owner”，没有登录鉴权与多用户切换。
- server.js 通过 `getOwnerId()` 取最早创建的 user 作为 owner。

### 3.2 devices（设备）
- 每条 storage_locations 记录都可关联一个 device_id
- 关键字段：
  - device_id：UUID
  - user_id：归属
  - device_name/device_type：展示
  - device_key：稳定身份（Android 使用 android:<ANDROID_ID>）用于去重
  - lan_url/transfer_token：局域网传输用（让别的设备找到这台设备，并做简单鉴权）

为什么需要 device_key：
- Android 重新安装后本地可能生成新的随机 device_id
- 但 ANDROID_ID 通常稳定
- 服务端以 (user_id, device_key) 为准做合并，避免“重复设备”

### 3.3 folders（虚拟文件夹）
- 树结构：parent_id 指向 folders.folder_id
- sort_order：同级排序（拖拽/重排写入）

### 3.4 media_items（资源条目）
- 一条资源就是一个“资产元数据”：
  - title/media_type/description
  - folder_id：归属文件夹
  - deleted_at：软删除（回收站）

### 3.5 storage_locations（位置/副本）
- 核心思想：一个资源可以有多个位置
- 位置类型：
  - storage_type='Local'：本地路径（PC 路径 / Android content://）
  - storage_type='Web'：URL
- 关键字段：
  - path：路径或 URL
  - access_info：补充访问方式（Android 用 android_uri）
  - device_id：该副本属于哪个设备
  - is_available：PC 端可刷新“路径是否存在”

### 3.6 tags / media_tags
- tags：标签字典（user_id + tag_name 唯一）
- media_tags：多对多关联

---

## 4. 桌面端（server.js）功能模块拆解

### 4.1 启动与初始化
- DB 路径：默认 `db/media-archive.db`，Electron 模式下通过环境变量 `DB_PATH` 指向用户数据目录
- initializeDatabase：
  - 读取 schema.sql 建表
  - 执行运行时迁移（ensure*）补列/补索引
  - 若 users 表为空：创建 owner + 默认设备 + 默认文件夹

### 4.2 Web UI 静态资源
- `app.use(express.static(public))`：访问 `/` 即打开前端页面

### 4.3 资源 API（媒体、位置、回收站）
- `GET /api/media`：主列表（支持 search/folderId/deviceId/mediaType/tagId/trash）
- `POST /api/media`：新增元数据条目 + 一个 location
- `POST /api/media/upload`：上传文件到桌面端 uploads，并入库（Local location 指向 uploads 文件路径）
- `PUT /api/media/:id`：编辑元数据
- `POST /api/media/:id/tags`：重设标签
- `POST /api/media/:id/location`：为同一资源追加一个 location
- `DELETE /api/media/:id`：默认软删除；force=true 硬删除
- `POST /api/media/:id/restore`：从回收站恢复
- `POST /api/trash/empty`：清空回收站

打开/预览/下载：
- `POST /api/media/:itemId/open`：仅允许 localhost 调用（安全）
- `GET /api/media/:itemId/preview`：浏览器 inline 预览
- `GET /api/media/:itemId/download`：下载 attachment

### 4.4 文件夹/标签/设备 API
- folders：create / rename(patch) / delete / reorder
- tags：create / delete（删除前检查是否被引用）
- devices：create / delete（删除前检查是否被引用）

---

## 5. 同步协议设计（push / pull / bootstrap）

同步目标：让多设备共享同一份“元数据视图”，并在需要时能按需访问远端文件。

### 5.1 bootstrap：初始化字典数据
- `GET /api/bootstrap`
- 返回：user、devices、folders、tags
- 用途：
  - Web UI 启动时拉取并渲染左侧文件夹树、设备列表、标签
  - Android 在同步后拉取 folders/devices 用于“文件夹/设备/全部”三视图

### 5.2 pull：拉取增量
- `GET /api/sync/pull?since=<ISO>`
- 服务端按 updated_at 返回：
  - media_items（默认过滤 deleted_at IS NULL）
  - 对每个 item 附带 locations 数组
  - devices（为了让客户端显示设备名/类型）
  - server_time（客户端保存为下次 since）

注意：
- 当前 pull 默认不返回回收站内容（deleted_at != NULL）。
- 如果要做“移动端回收站视图”，需要扩展参数或额外接口。

### 5.3 push：推送变更
- `POST /api/sync/push`
- payload：
  - device：设备信息（含 device_key/lan_url/transfer_token）
  - items：媒体条目数组（含 locations）
  - deleted_item_ids：本机删除的 item_id 列表（用于同步软删除）

服务端处理关键点：
- 先 `upsertDeviceForOwner()`：基于 device_key 合并重复设备，并迁移引用
- 再 upsert 每条 media_item 与 storage_location
- 为避免 “FK constraint failed”：写 location 前会把 loc.device_id 规范化到 canonical device_id（尤其是 Android 重装导致的 device_id 变化）

---

## 6. 局域网传输原理（下载/流式）

问题：
- 桌面端数据库里可能存在 location.path=`content://...`，文件实际在手机上
- 桌面端无法直接读取 content://

解决：
- 手机端启动一个 LAN HTTP server（带 token）
- 手机在 push 时把 `lan_url` 与 `transfer_token` 写入 devices
- 桌面端在用户点击该资源时：
  1) 弹窗让用户选择“下载到本机 / 流式”
  2) 桌面端根据 locationId 找到该 location 所属设备 → 取 lan_url + token
  3) 对手机端发起拉取或代理流式

接口：
- 桌面端：
  - `POST /api/transfer/pull-from-phone`：下载落盘到 uploads，生成新的 Local location
  - `GET /api/transfer/stream-from-device`：302/代理方式让浏览器直接播放/预览

---

## 7. Android 端实现要点

### 7.1 为什么必须用 SAF（content://）
- Android 10+ 普通路径访问受限
- 用系统文件选择器 ACTION_OPEN_DOCUMENT 得到 content:// URI
- 尝试申请 persistable permission，保证重启后仍可读

### 7.2 本地索引库（Room）
- 只保存元数据（显示名、uri、时间戳、deviceId、folderId、mediaType…）
- 注意：本地表的自增主键不等于服务器 item_id，需要以 itemId 为准做 upsert/更新

### 7.3 同步流程（MainViewModel.syncNow）
- push：只推送本机 content:// 项（避免把 PC 路径当成手机位置回推）
- pull：拉取增量 items+locations
- bootstrap：拉 folders/devices 供 UI 使用
- 规范化 device_id：push 返回 canonical device_id 时，把本地 content:// 行的 deviceId 统一更新，确保“设备视图”能正确筛选

---

## 8. 交互流程（对照 UI）

### 8.1 桌面 Web UI（public/app.js）
- 启动：调用 `/api/bootstrap` 拉 folders/devices/tags
- 列表：调用 `/api/media`（根据筛选条件拼 query）
- 点击资源：
  - Web 链接：直接打开
  - 本地路径：localhost 下调用 `/api/media/:id/open`，否则走 `/download`
  - Android content://：弹窗选择下载/流式，调用 transfer 接口

### 8.2 Android App（Compose）
- 三个 Tab：文件夹 / 设备 / 全部
- 文件夹 Tab：根据 remoteFolders 构造树形进入/返回；列表中再渲染当前 folderId 下的 items
- 点击条目：
  - content://：交给系统打开
  - http(s)://：交给系统浏览器打开
  - 其它（PC 路径）：弹窗选择“下载/流式”，实际是访问桌面端 `/api/media/:id/download|preview`（由桌面端去处理本地文件）

---

## 9. 如何扩展（可选方向）

- 多用户：增加登录鉴权与 user_id 切换，所有 API 基于会话用户隔离
- 真正的“跨设备文件同步”：需要明确存储策略（复制到谁、何时复制、冲突如何解决）
- 回收站同步：pull 支持 trash 参数或提供 `/api/trash` 专门列表

---

## 10. 快速定位：我想改某个功能，应该看哪里？

- 改 Web UI 交互/样式：`public/app.js` / `public/styles.css`
- 改 API 行为：`server.js`
- 改数据库结构：`db/schema.sql`（同时注意 server.js 的运行时 ensure* 迁移）
- 改 Electron 启动/端口/数据目录：`electron/main.js`
- 改 Android UI：`mobile-android/app/src/main/java/.../MainActivity.kt`
- 改 Android 同步：`mobile-android/app/src/main/java/.../MainViewModel.kt`、`SyncClient.kt`
- 改 Android 本地库：`AppDatabase.kt`、`IndexedFileDao.kt`、`FileRepository.kt`
