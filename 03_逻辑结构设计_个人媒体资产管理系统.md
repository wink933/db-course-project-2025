# 数据库项目设计文档 (三)：逻辑结构设计 (关系模式)

## 1. 设计概述
本阶段将概念设计中的 E-R 图转化为具体的关系数据库模式（Relational Schema）。
考虑到系统**“多设备同步”**的核心需求，主键策略选用 **UUID (通用唯一识别码)**，以避免不同设备在离线生成数据时产生 ID 冲突。

## 2. 关系模式定义 (Relational Schemas)

### 2.1 基础实体表

#### (1) 用户表 (User)
*   **表名**：`users`
*   **描述**：存储用户信息。
*   **模式**：`users(user_id, username, created_at)`
*   **主键**：`user_id`

#### (2) 设备表 (Device)
*   **表名**：`devices`
*   **描述**：存储用户拥有的设备信息。
*   **模式**：`devices(device_id, user_id, device_name, device_type, last_sync_time)`
*   **主键**：`device_id`
*   **外键**：`user_id` → `users.user_id`

#### (3) 文件夹表 (Folder)
*   **表名**：`folders`
*   **描述**：存储虚拟文件夹层级结构。
*   **模式**：`folders(folder_id, user_id, parent_id, folder_name, created_at)`
*   **主键**：`folder_id`
*   **外键**：
    *   `user_id` → `users.user_id`
    *   `parent_id` → `folders.folder_id` (自关联，可为空，空代表根目录)

#### (4) 标签表 (Tag)
*   **表名**：`tags`
*   **描述**：存储用户定义的标签。
*   **模式**：`tags(tag_id, user_id, tag_name)`
*   **主键**：`tag_id`
*   **外键**：`user_id` → `users.user_id`

### 2.2 核心业务表

#### (5) 媒体项表 (MediaItem)
*   **表名**：`media_items`
*   **描述**：存储媒体资源的逻辑信息（不包含物理路径）。
*   **模式**：`media_items(item_id, user_id, folder_id, title, media_type, description, created_at, updated_at)`
*   **主键**：`item_id`
*   **外键**：
    *   `user_id` → `users.user_id`
    *   `folder_id` → `folders.folder_id`

#### (6) 存储位置表 (StorageLocation)
*   **表名**：`storage_locations`
*   **描述**：存储媒体资源的物理位置或网络链接。
*   **模式**：`storage_locations(location_id, item_id, device_id, storage_type, path, access_info, is_available)`
*   **主键**：`location_id`
*   **外键**：
    *   `item_id` → `media_items.item_id` (级联删除)
    *   `device_id` → `devices.device_id` (可为空，当 `storage_type`='Web' 时)

### 2.3 关联表 (Association Tables)

#### (7) 媒体-标签关联表 (MediaTag)
*   **表名**：`media_tags`
*   **描述**：实现媒体与标签的多对多关系。
*   **模式**：`media_tags(item_id, tag_id)`
*   **主键**：`(item_id, tag_id)` (复合主键)
*   **外键**：
    *   `item_id` → `media_items.item_id`
    *   `tag_id` → `tags.tag_id`

---

## 3. 规范化分析 (Normalization)

### 3.1 第一范式 (1NF)
*   **分析**：所有表的字段均为原子值，不可再分。
*   **符合情况**：符合。例如 `StorageLocation` 中的 `access_info` 虽然可能包含账号密码等信息，但在本系统中被视为一个整体备注字符串处理，不涉及数据库层面的拆解查询。

### 3.2 第二范式 (2NF)
*   **分析**：所有非主属性完全依赖于主键。
*   **符合情况**：符合。
    *   在 `media_tags` 表中，不存在仅依赖于 `item_id` 或 `tag_id` 的非主属性（该表只有两个主键字段，无其他属性）。
    *   其他表均为单字段主键，自然符合 2NF。

### 3.3 第三范式 (3NF)
*   **分析**：不存在非主属性对主键的传递依赖。
*   **符合情况**：符合。
    *   例如在 `media_items` 表中，`folder_id` 决定了文件夹信息，但文件夹的具体名称存储在 `folders` 表中，`media_items` 只存 ID，消除了传递依赖。
    *   `storage_locations` 表中，`device_id` 决定设备信息，同样通过外键引用，未在存储位置表中冗余设备名称。

---

## 4. 数据完整性设计 (Integrity Constraints)

### 4.1 实体完整性
*   所有表的主键 (`PK`) 均不能为空且唯一。
*   使用 UUID 生成算法保证分布式环境下的唯一性。

### 4.2 参照完整性 (外键策略)
*   **MediaItem 删除时**：
    *   `StorageLocation`：**CASCADE (级联删除)**。逻辑实体没了，物理位置记录也就没有意义了。
    *   `MediaTag`：**CASCADE (级联删除)**。关联关系随之消失。
*   **Folder 删除时**：
    *   `MediaItem`：**RESTRICT (限制)** 或 **SET NULL**。防止误删文件夹导致大量文件记录丢失，通常要求先清空文件夹或移动文件。MVP 阶段可设为 `RESTRICT`。
*   **Device 删除时**：
    *   `StorageLocation`：**CASCADE**。设备移除了，该设备上的文件记录自然失效。

### 4.3 用户定义完整性
*   `users.username`：**UNIQUE**，用户名不可重复。
*   `storage_locations.storage_type`：**CHECK**，只能是 'Local' 或 'Web'。
*   `media_items.title`：**NOT NULL**，标题不能为空。
